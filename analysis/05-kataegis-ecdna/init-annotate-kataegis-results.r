#!/nfs/sw/R/R-4.0.0/bin/Rscript
################################################################################
### COPYRIGHT ##################################################################

# New York Genome Center

# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright (2023) by the New York
# Genome Center. All rights are reserved. This software is supplied without
# any warranty or guaranteed support whatsoever. The New York Genome Center
# cannot be responsible for its use, misuse, or functionality.

# Author: William F. Hooper

################################################################# /COPYRIGHT ###
################################################################################
## Annotate kataegis mutations as generated by SigProfilerClusters
libs = c('optparse', 'stringr', 'VariantAnnotation', 'reshape2')
invisible(suppressPackageStartupMessages(sapply(libs, require, character.only=T)))
options(width=200, scipen=999)



## Read SigProfilerClusters VCF
## Can't use VariantAnnotation::readVcf because 
## header is missing
read.sigprofiler.vcf = function(f, flag) {

  if (!file.exists(f)) {
    return(NULL)
  }

  x = read.csv(f, h=T, stringsAsFactors=F, sep='\t')
  
  ## Extract some info 
  x[, flag] = as.numeric(str_extract(x$INFO, '(?<=VAF=).*(?=;)'))
  x$sample = gsub('--.*', '', x$ID)
  x$kataegis_id = paste0(x$sample, '_', str_extract(x$INFO, '(?<=groupNumber).*$'))

  ## Update columns
  x = x[, !colnames(x) %in% c('ID', 'INFO')]
  colnames(x) = tolower(gsub('^X\\.', '', colnames(x)))
  x$chrom = paste0('chr', x$chrom)

  ## Add mutation ID
  x$mutation_id = paste0(x$chrom, ':', x$pos) 

  return(x)

}



## Parse VEP annotations from a vcf object (default field is CSQ)
parse.vep = function(vcf, field='CSQ') { 
  
  ## Get format 
  frm = info(header(vcf))[field, 'Description']
  frm = gsub('^.*Format: ', '', frm)  
  frm = unlist(strsplit(frm, '|', fixed=T))  
  
  ## Read field
  colnames(info(vcf))
  x = unlist(info(vcf)[, field])
  
  ## Split into data frame
  x = colsplit(x, pattern='\\|', names=frm)
  
  x$IMPACT = trimws(x$IMPACT)
  
  return(x)
  
}



read.junctions = function(f) {
  
  gg = readRDS(f)
  junc = unlist(gg$junctions[type == 'ALT']$grl) 
  junc = junc[!junc$loose]
  junc = granges(junc)

  return(junc)
  
}



## Get arguments
option_list = list(
  make_option(c("-i", "--in_file_ktg"),   type='character', help="Input SigProfilerClusters 'VCF'"),
  make_option(c("-I", "--in_file_sig"),   type='character', help="VCF that has run through the signature assignment pipeline"),
  make_option(c("-j", "--in_file_jba"),   type='character', help="Jabba gGraph RDS"),
  make_option(c("-f", "--ktg_flag"),      type='character', help="Flag to set SigProfilerClusters run type"),
  make_option(c("-t", "--tumor"),         type='character', help="Tumor ID"),
  make_option(c("-c", "--apobec_cutoff"), type='numeric',   help="Minimum proportion of mutations in a kataegis event that must be assigned to APOBEC to call the kataegis event APOBEC-associated"),
  make_option(c("-o", "--out_file"),      type='character', help="TSV output file"))
opt = parse_args(OptionParser(option_list=option_list))



## Read data
ktg = read.sigprofiler.vcf(opt$in_file_ktg, flag=opt$ktg_flag)
sig = VariantAnnotation::readVcf(opt$in_file_sig)
jba = read.junctions(opt$in_file_jba)


## Add trinucleotide context and multiplicity
info(sig)$tricontext = as.character(info(sig)$tricontext)
info(sig)$total_cn = info(sig)$MajCN + info(sig)$MinCN
rownames(sig) = paste0(as.character(seqnames(rowRanges(sig))),':',start(rowRanges(sig)))


## Add a few ensembl annotations
ens.cols = c('SYMBOL', 'IMPACT', 'Consequence')
info(sig)[, ens.cols] = parse.vep(sig)[, ens.cols]


## Add annotations where possible. DBS don't have signature assignments
## but they look like SNVs in the sigprofilerclusters output 
info(sig)$t_ref_count = sapply(geno(sig)$AD[,opt$tumor], function(x) x[1])
info(sig)$t_alt_count = sapply(geno(sig)$AD[,opt$tumor], function(x) x[2])
info(sig)$vaf = info(sig)$t_alt_count / (info(sig)$t_alt_count + info(sig)$t_ref_count)

anno = c(ens.cols, 'tricontext', 'assigned_signature', 'vaf', 'MutCN', 'total_cn')
ktg[ktg$mutation_id %in% rownames(sig), anno] = unlist(info(sig)[match(ktg$mutation_id[ktg$mutation_id %in% rownames(sig)], rownames(sig)), anno])
ktg$assigned_signature[is.na(ktg$assigned_signature)] = 'unassigned'
ktg$tricontext[is.na(ktg$tricontext)] = 'DBS'
ktg$mutation_cn = ktg$MutCN


## For each kataegis event, get proportion of mutations assigned to apobec,
## nominate events as apobec-associated
assigned.sig = as.data.frame.matrix(table(ktg$kataegis_id, ktg$assigned_signature))

if (is.null(assigned.sig$SBS2)) assigned.sig$SBS2 = 0
if (is.null(assigned.sig$SBS13)) assigned.sig$SBS13 = 0

assigned.sig$prop = (assigned.sig$SBS2 + assigned.sig$SBS13) / rowSums(assigned.sig)
assigned.sig$apobec_associated = assigned.sig$prop >= opt$apobec_cutoff
ktg$apobec_associated = assigned.sig$apobec_associated[match(ktg$kataegis_id, rownames(assigned.sig))]


## Annotate with distance to the nearest breakpoint
ktg$end = ktg$pos
ktg$distance_to_nearest_junction = NA
ktg.gr = makeGRangesFromDataFrame(ktg, seqnames.field='chrom', start.field='pos', end.field='end', keep.extra.columns=T)

dist.to.junc = distanceToNearest(ktg.gr, jba, ignore.strand=T)
ktg$distance_to_nearest_junction[queryHits(dist.to.junc)] = mcols(dist.to.junc)$distance

if(!all(ktg$pos == start(ktg.gr))) stop('Issue with finding nearest junction')


## Write result
cols = c('chrom', 'pos', 'ref', 'alt', 'vaf', opt$ktg_flag, ens.cols, 'mutation_cn', 'total_cn', 'sample', 'kataegis_id', 
         'tricontext', 'assigned_signature', 'apobec_associated', 'distance_to_nearest_junction')

ktg = ktg[, cols]


write.table(ktg, opt$out_file, row.names=F, col.names=T, quote=F, sep='\t')
message(opt$out_file)

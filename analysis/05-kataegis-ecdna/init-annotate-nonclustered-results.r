#!/nfs/sw/R/R-4.0.0/bin/Rscript
################################################################################
### COPYRIGHT ##################################################################

# New York Genome Center

# SOFTWARE COPYRIGHT NOTICE AGREEMENT
# This software and its documentation are copyright (2023) by the New York
# Genome Center. All rights are reserved. This software is supplied without
# any warranty or guaranteed support whatsoever. The New York Genome Center
# cannot be responsible for its use, misuse, or functionality.

# Author: William F. Hooper

################################################################# /COPYRIGHT ###
################################################################################
## Annotate non-kataegis mutations as generated by SigProfilerClusters 
libs = c('optparse', 'stringr', 'VariantAnnotation', 'reshape2')
invisible(suppressPackageStartupMessages(sapply(libs, require, character.only=T)))
options(width=200, scipen=999)



## Read SigProfilerClusters VCF
## Can't use VariantAnnotation::readVcf because 
## header is missing
read.sigprofiler.vcf = function(f) {

  if (!file.exists(f)) {
    return(NULL)
  }

  x = read.csv(f, h=T, stringsAsFactors=F, sep='\t')
  
  ## Extract some info 
  x$sample = gsub('--.*', '', x$ID)

  ## Update columns
  x = x[, !colnames(x) %in% c('INFO')]
  colnames(x) = tolower(gsub('^X\\.', '', colnames(x)))
  x$chrom = paste0('chr', x$chrom)

  ## Add mutation ID
  x$mutation_id = paste0(x$chrom, ':', x$pos) 

  return(x)

}



## Parse VEP annotations from a vcf object (default field is CSQ)
parse.vep = function(vcf, field='CSQ') { 
  
  ## Get format 
  frm = info(header(vcf))[field, 'Description']
  frm = gsub('^.*Format: ', '', frm)  
  frm = unlist(strsplit(frm, '|', fixed=T))  
  
  ## Read field
  colnames(info(vcf))
  x = unlist(info(vcf)[, field])
  
  ## Split into data frame
  x = colsplit(x, pattern='\\|', names=frm)
  
  x$IMPACT = trimws(x$IMPACT)
  
  return(x)
  
}



read.junctions = function(f) {
  
  gg = readRDS(f)
  junc = unlist(gg$junctions[type == 'ALT']$grl) 
  junc = junc[!junc$loose]
  junc = granges(junc)

  return(junc)
  
}



## Get arguments
option_list = list(
  make_option(c("-i", "--in_file_nc"),    type='character', help="Input SigProfilerClusters 'VCF' - non clustered results"),
  make_option(c("-I", "--in_file_sig"),   type='character', help="VCF that has run through the signature assignment pipeline"),
  make_option(c("-j", "--in_file_jba"),   type='character', help="Jabba gGraph RDS"),
  make_option(c("-t", "--tumor"),         type='character', help="Tumor ID"),
  make_option(c("-c", "--apobec_cutoff"), type='numeric',   help="Minimum proportion of mutations in a kataegis event that must be assigned to APOBEC to call the kataegis event APOBEC-associated"),
  make_option(c("-o", "--out_file"),      type='character', help="TSV output file"))
opt = parse_args(OptionParser(option_list=option_list))



## Read data
vcf = read.sigprofiler.vcf(opt$in_file_nc)
sig = VariantAnnotation::readVcf(opt$in_file_sig)
jba = read.junctions(opt$in_file_jba)


## Add trinucleotide context and multiplicity 
info(sig)$tricontext = as.character(info(sig)$tricontext)
info(sig)$total_cn = info(sig)$MajCN + info(sig)$MinCN
rownames(sig) = paste0(as.character(seqnames(rowRanges(sig))),':',start(rowRanges(sig)))


## Add a few ensembl annotations
ens.cols = c('SYMBOL', 'IMPACT', 'Consequence')
info(sig)[, ens.cols] = parse.vep(sig)[, ens.cols]


## Add annotations where possible. DBS don't have signature assignments
## but they look like SNVs in the sigprofilerclusters output 
info(sig)$t_ref_count = sapply(geno(sig)$AD[,opt$tumor], function(x) x[1])
info(sig)$t_alt_count = sapply(geno(sig)$AD[,opt$tumor], function(x) x[2])
info(sig)$vaf = info(sig)$t_alt_count / (info(sig)$t_alt_count + info(sig)$t_ref_count)

anno = c(ens.cols, 'tricontext', 'assigned_signature', 'vaf', 'MutCN', 'MT_CCF', 'total_cn')
vcf[vcf$mutation_id %in% rownames(sig), anno] = unlist(info(sig)[match(vcf$mutation_id[vcf$mutation_id %in% rownames(sig)], rownames(sig)), anno])
vcf$assigned_signature[is.na(vcf$assigned_signature)] = 'unassigned'
vcf$tricontext[is.na(vcf$tricontext)] = 'DBS'
vcf$mutation_cn = vcf$MutCN
vcf$ccf = vcf$MT_CCF


## Annotate with distance to the nearest breakpoint
vcf$end = vcf$pos
vcf$distance_to_nearest_junction = NA
vcf.gr = makeGRangesFromDataFrame(vcf, seqnames.field='chrom', start.field='pos', end.field='end', keep.extra.columns=T)

dist.to.junc = distanceToNearest(vcf.gr, jba, ignore.strand=T)
vcf$distance_to_nearest_junction[queryHits(dist.to.junc)] = mcols(dist.to.junc)$distance

if(!all(vcf$pos == start(vcf.gr))) stop('Issue with finding nearest junction')


## Write result
cols = c('chrom', 'pos', 'ref', 'alt', 'vaf', 'ccf', ens.cols, 'mutation_cn', 'total_cn', 'sample', 
         'tricontext', 'assigned_signature', 'distance_to_nearest_junction')
vcf = vcf[, cols]

write.table(vcf, opt$out_file, row.names=F, col.names=T, quote=F, sep='\t')
message(opt$out_file)
